{
  "hash": "5832968b6f5d8dfa2570292d6c9dca1c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Debugging, Profiling, and a Bit of Optimization\"\nauthor: \"Marcin Kierczak\"\nimage: \"assets/featured.webp\"\nformat: revealjs\n---\n\n\n\n\n## {visibility=\"hidden\"}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\nlibrary(DT)\nlibrary(profvis)\nlibrary(Rgraphviz)\nlibrary(proftools) # depends on \"graph\" and \"Rgraphviz\" packages\nlibrary(profr)\nlibrary(pryr)\nlibrary(microbenchmark)\nlibrary(ggplot2)\n# remotes::install_github(\"hadley/emo\")\nlibrary(emo)\n# remotes::install_github(\"cdeterman/gpuR\")\n#library(gpuR)\n```\n:::\n\n\n\n\n## Run Forrest, run!\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n<br><br><br>\n\n::: {.incremental}\n\n- *My code does not run!* -- **debugging**<br><br>\n- *Now it does run but... out of memory!* -- **profiling**<br><br>\n- *It runs! It says it will finish in 5 ~~minutes~~ years.* -- **optimization**\n\n:::\n:::\n::: {.column width=\"50%\"}\n\n<img src=\"assets/resources.jpg\" style=\"width:80%;\"/>\n\n:::\n::::\n\n## Types of bugs {background-image=\"assets/featured.webp\"}\n\n- üî£ Syntax errors\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2\"}\nprint(var1) \nmean(sum(seq((x + 2) * (y - 9 * b))))\n```\n:::\n\n\n\n\n. . .\n\n- üî¢ Arithmetic \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- 7 / 0\n```\n:::\n\n\n\n*Not in R though! `y = Inf`*\n\n. . .\n\n- üçéüçä Type \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean('a')\n```\n:::\n\n\n\n\n. . .\n\n- üß© Logic\n\nEverything works and produces seemingly valid output that is WRONG!  \nIMHO those are the hardest üíÄ to debug!\n\n## How to avoid bugs\n\n<br><br><br>\n\n::: {.incremental}\n\n- Encapsulate your code in smaller units üç± (functions), you can test.<br><br>\n- Use classes and type checking üÜó.<br><br>\n- Test üß™ at the boundaries, e.g. loops at min and max value.<br><br>\n- Feed your functions with test data üíæ that should result with a known output.<br><br>\n- Use *antibugging* üï∏: `stopifnot(y <= 75)`\n\n:::\n\n## Floating confusion\n\n<br><br>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"1|2-3\"}\n(vec <- seq(0.1, 0.9, by=0.1))\nvec == 0.7 \nvec == 0.5\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9\n[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n<br>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(0.5 + 0.1) - 0.6\n(0.7 + 0.1) - 0.8 \n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n[1] -1.110223e-16\n```\n\n\n:::\n:::\n\n\n\n\n<br/>\n\n<div style=\"text-align:center;\"/>\nüíÄ Beware of floating point arithmetic! üíÄ\n</div/>\n\n## How to float üèä\n<br><br>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround((0.7 + 0.1) , digits = 2) - 0.8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\nComparing floating point numbers: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vec <- seq(0.1, 0.9, by=0.1))\nvec == 0.7\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9\n[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepsilon <- 0.001\nabs(vec - 0.7) <= epsilon\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Final thoughts on floating \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(unlist(.Machine))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    double.eps double.neg.eps    double.xmin    double.xmax    double.base \n  2.220446e-16   1.110223e-16  2.225074e-308  1.797693e+308   2.000000e+00 \n double.digits \n  5.300000e+01 \n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(unlist(.Platform))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   OS.type   file.sep dynlib.ext        GUI     endian    pkgType \n    \"unix\"        \"/\"      \".so\"      \"X11\"   \"little\"   \"source\" \n```\n\n\n:::\n:::\n\n\n\n\n## Handling Errors\n\nLet us generate some errors:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- c(1, 10, -7, -2/5, 0, 'char', 100, pi, NaN)\nfor (val in input) {\n  (paste0('Log of ', val, 'is ', log10(val)))\n}\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in log10(val): non-numeric argument to mathematical function\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n:::: {.columns}\n::: {.column width=\"30%\"}\n\n<img src = \"assets/ui_ux_error.jpg\" style=\"width: 100%\"/>\n\n:::\n::: {.column width=\"70%\"}\n\n<br><br><br><br>So, how to handle this mess?\n\n:::\n::::\n\n## Handling Errors -- `try`\n<br><br>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(\n  print(\n    paste0('Log of ', input, ' is ', log10(as.numeric(input)))\n  )\n)\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Log of 1 is 0\"                               \n[2] \"Log of 10 is 1\"                              \n[3] \"Log of -7 is NaN\"                            \n[4] \"Log of -0.4 is NaN\"                          \n[5] \"Log of 0 is -Inf\"                            \n[6] \"Log of char is NA\"                           \n[7] \"Log of 100 is 2\"                             \n[8] \"Log of 3.14159265358979 is 0.497149872694133\"\n[9] \"Log of NaN is NaN\"                           \n```\n\n\n:::\n:::\n\n\n\n\n## Handling Errors -- `tryCatch` block:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- tryCatch(log10(val), \n            warning = function(w) { \n              print('Warning! Negative argument supplied. Negating.') \n              log10(-val) }, \n            error = function(e) { \n              print('ERROR! Not a number!')\n              NaN\n            }\n          )\n```\n:::\n\n\n\n\n. . .\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Log of 1 is 0\"\n[1] \"Log of 10 is 1\"\n[1] \"Warning! Negative argument supplied. Negating.\"\n[1] \"Log of -7 is 0.845098040014257\"\n[1] \"Warning! Negative argument supplied. Negating.\"\n[1] \"Log of -0.4 is -0.397940008672038\"\n[1] \"Log of 0 is -Inf\"\n[1] \"Log of NA is NA\"\n[1] \"Log of 100 is 2\"\n[1] \"Log of 3.14159265358979 is 0.497149872694133\"\n[1] \"Log of NaN is NaN\"\n```\n\n\n:::\n:::\n\n\n\n\n## Debugging -- errors and warnings\n\n::: {.incremental}\n\n- An error in your code will result in a call to the `stop()` function that:\n  - Breaks the execution of the program (loop, if-statement, etc.)\n  - Performs the action defined by the global parameter `error`.\n- A warning just prints out the warning message (or reports it in another way)\n\n:::\n\n. . .\n\n- Global parameter `error` defines what R should do when an error occurs.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(error = )\n```\n:::\n\n\n\n\n. . .\n\n- You can use `simpleError()` and `simpleWarning()` to generate errors and warnings in your code:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"4\"}\nf <- function(x) {\n  if (x < 0) {\n    x <- abs(x)\n    w <- simpleWarning(\"Value less than 0. Taking abs(x)\")\n    w\n  }\n}\n```\n:::\n\n\n\n\n## Debugging -- what are my options?\n\n- Old-school debugging: a lot of `print` statements\n  - print values of your variables at some checkpoints,\n  - sometimes fine but often laborious,\n  - need to remove/comment out manually after debugging.\n\n. . .\n\n- Dumping frames\n  - on error, R state will be saved to a file,\n  - file can be read into debugger,\n  - values of all variables can be checked,\n  - can debug on another machine, e.g. send dump to your colleague!\n  \n. . .\n\n- Traceback\n  - a list of the recent function calls with values of their parameters\n  \n. . .\n\n- Step-by-step debugging\n  - execute code line by line within the debugger\n\n## Option 1: dumping frames\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|4-6\"}\nf <- function(x) { sin(x) }\noptions(error = quote(dump.frames(dumpto = \"assets/testdump\", to.file = T)))\nf('test')\noptions(error = NULL) # reset the behavior\nload('assets/testdump.rda')\n# debugger(testdump)\n```\n:::\n\n\n\n\nHint: Last empty line brings you back to the environments menu.\n\n## Option 2: traceback\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) { \n  log10(x) \n}\ng <- function(x) { \n  f(x) \n}\ng('test')\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in log10(x): non-numeric argument to mathematical function\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\n```\n> traceback()\n2: f(x) at #2\n1: g(\"test\")\n```\n\n`traceback()` shows what were the function calls and what parameters were passed to them when the error occurred.\n\n## Option 3: step-by-step debugging\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\nLet us define a new function `h(x, y)`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- function(x, y) { \n  f(x) \n  f(y) \n}\n```\n:::\n\n\n\n\nNow, we can use `debug()` to debug the function in a step-by-step manner:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug(h)\nh('text', 7)\nundebug(h)\n```\n:::\n\n\n\n\n:::\n\n::: {.column .fragment width=\"50%\"}\n\n![](assets/debug.png)\n\n:::\n::::\n\n## Profiling -- `proc.time()`\n\nProfiling is the process of **identifying memory** and time **bottlenecks** üçæ in your code.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  2.063   0.563   1.798 \n```\n\n\n:::\n:::\n\n\n\n\n- `user time` -- CPU time charged for the execution of user instructions of the calling process,\n- `system time` -- CPU time charged for execution by the system on behalf of the calling process,\n- `elapsed time` -- total CPU time elapsed for the currently running R process.\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npt1 <- proc.time()\ntmp <- runif(n =  10e5)\npt2 <- proc.time()\npt2 - pt1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.025   0.000   0.025 \n```\n\n\n:::\n:::\n\n\n\n\n## Profiling -- `system.time()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.time(runif(n = 10e6))\nsystem.time(rnorm(n = 10e6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   user  system elapsed \n  0.331   0.031   0.362 \n   user  system elapsed \n  0.488   0.024   0.512 \n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\nAn alternative approach is to use `tic` and `toc` statements from the `tictoc` package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\ntic()\ntmp1 <- runif(n = 10e6)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0.236 sec elapsed\n```\n\n\n:::\n:::\n\n\n\n\n## Profiling in action\n\nThese 4 functions fill a **large vector** with values supplied by function `f`.\n\n. . .\n\n1 -- loop without memory allocation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|3-5\"}\nfun_fill_loop1 <- function(n = 10e6, f) {\n  result <- NULL\n  for (i in 1:n) {\n    result <- c(result, eval(call(f, 1)))\n  }\n  return(result)\n}\n```\n:::\n\n\n\n\n. . .\n\n2 -- loop with memory allocation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|3-5\"}\nfun_fill_loop2 <- function(n = 10e6, f) {\n  result <- vector(length = n)\n  for (i in 1:n) {\n    result[i] <- eval(call(f, 1))\n  }\n  return(result)\n}\n```\n:::\n\n\n\n\n## Profiling in action cted.\n\nBut it is maybe better to use...\n\n. . .\n\nvectorization!\n\n. . .\n\n3 -- vectorized loop without memory allocation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|3\"}\nfun_fill_vec1 <- function(n = 10e6, f) {\n  result <- NULL\n  result <- eval(call(f, n))\n  return(result)\n}\n```\n:::\n\n\n\n\n. . .\n\n4 -- vectorized with memory allocation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|3\"}\nfun_fill_vec2 <- function(n = 10e6, f) {\n  result <- vector(length = n)\n  result <- eval(call(f, n))\n  return(result)\n}\n```\n:::\n\n\n\n\n## Profiling our functions\n<br>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- system.time(fun_fill_loop1(n = 10e4, \"runif\")) # 1 - loop, no alloc\np2 <- system.time(fun_fill_loop2(n = 10e4, \"runif\")) # 2 - loop, alloc \np3 <- system.time(fun_fill_vec1(n = 10e4, \"runif\"))  # 3 - vector, no alloc\np4 <- system.time(fun_fill_vec2(n = 10e4, \"runif\"))  # 4 - vector, alloc\n```\n:::\n\n\n|fn  | user.self| sys.self| elapsed|\n|:---|---------:|--------:|-------:|\n|fn1 |     7.644|    0.166|   7.811|\n|fn2 |     0.479|    0.000|   0.480|\n|fn3 |     0.001|    0.000|   0.002|\n|fn4 |     0.002|    0.000|   0.002|\n\n\n\n\nThe `system.time()` function is not the most accurate though. During the lab, we will experiment with package `microbenchmark`.\n\n## More advanced profiling\n\nWe can also do a bit more advanced profiling, including the memory profiling, using, e.g. `Rprof()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRprof('profiler_test.out', interval = 0.01, memory.profiling = T)\nfor (i in 1:5) {\n  result <- fun_fill_loop2(n = 10e4, \"runif\")\n  print(head(result))\n}\nRprof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6536342 0.6183371 0.6189789 0.3408437 0.2664858 0.6185547\n[1] 0.6383574 0.5914124 0.2921400 0.3233635 0.9352206 0.1025050\n[1] 0.98932042 0.03798655 0.64528481 0.83488187 0.14626268 0.32709305\n[1] 0.63197483 0.32713220 0.34499497 0.32908306 0.26927382 0.09823248\n[1] 0.569201405 0.860486382 0.096056464 0.941512789 0.001748405 0.055280883\n```\n\n\n:::\n:::\n\n\n\n\nAnd let us summarise:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary <- summaryRprof(\"profiler_test.out\", memory = \"both\")\nknitr::kable(summary$by.self)\nunlink(\"profiler_test.out\")\n```\n\n::: {.cell-output-display}\n\n\n|                 | self.time| self.pct| total.time| total.pct| mem.total|\n|:----------------|---------:|--------:|----------:|---------:|---------:|\n|\"eval\"           |      1.51|    53.17|       2.84|    100.00|    1616.6|\n|\"force\"          |      0.60|    21.13|       0.72|     25.35|     453.0|\n|\"runif\"          |      0.34|    11.97|       0.34|     11.97|     204.6|\n|\"fun_fill_loop2\" |      0.27|     9.51|       2.84|    100.00|    1616.6|\n|\"parent.frame\"   |      0.08|     2.82|       0.08|      2.82|      46.0|\n|\"is.pairlist\"    |      0.02|     0.70|       0.02|      0.70|      14.2|\n|\"baseenv\"        |      0.01|     0.35|       0.01|      0.35|       5.0|\n|\"is.list\"        |      0.01|     0.35|       0.01|      0.35|       9.7|\n\n\n:::\n:::\n\n\n\n\n## Profiling -- `profr` package\n\nThere are also packages available that enable even more advanced profiling:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(profr)\nRprof(\"profiler_test2.out\", interval = 0.01)\ntmp <- table(sort(rnorm(1e5)))\nRprof(NULL)\nprofile_df <- parse_rprof('profiler_test2.out')\n```\n:::\n\n\n\n\nThis returns a table that can be visualised:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| level| g_id| t_id|f                   | start|  end|  n|leaf  | time|source       |\n|-----:|----:|----:|:-------------------|-----:|----:|--:|:-----|----:|:------------|\n|     1|    1|    1|.main               |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     2|    1|    1|execute             |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     3|    1|    1|rmarkdown::render   |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     4|    1|    1|knitr::knit         |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     5|    1|    1|process_file        |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     6|    1|    1|xfun:::handle_error |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     7|    1|    1|withCallingHandlers |     0| 0.30|  1|FALSE | 0.30|base         |\n|     8|    1|    1|process_group       |     0| 0.30|  1|FALSE | 0.30|NA           |\n|     9|    1|    1|call_block          |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    10|    1|    1|block_exec          |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    11|    1|    1|eng_r               |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    12|    1|    1|in_input_dir        |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    13|    1|    1|in_dir              |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    14|    1|    1|evaluate            |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    15|    1|    1|evaluate::evaluate  |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    16|    1|    1|withRestarts        |     0| 0.30|  1|FALSE | 0.30|base         |\n|    17|    1|    1|withRestartList     |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    18|    1|    1|withOneRestart      |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    19|    1|    1|doWithOneRestart    |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    20|    1|    1|withRestartList     |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    21|    1|    1|withOneRestart      |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    22|    1|    1|doWithOneRestart    |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    23|    1|    1|with_handlers       |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    24|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    25|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    26|    1|    1|withCallingHandlers |     0| 0.30|  1|FALSE | 0.30|base         |\n|    27|    1|    1|withVisible         |     0| 0.30|  1|FALSE | 0.30|base         |\n|    28|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    29|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    30|    1|    1|table               |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    31|    1|    1|standardGeneric     |     0| 0.30|  1|FALSE | 0.30|base         |\n|    32|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    33|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    34|    1|    1|eval                |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    35|    1|    1|table               |     0| 0.30|  1|FALSE | 0.30|BiocGenerics |\n|    36|    1|    1|base::table         |     0| 0.30|  1|FALSE | 0.30|NA           |\n|    37|    1|    1|factor              |     0| 0.28|  1|FALSE | 0.28|base         |\n|    38|    1|    1|unique              |     0| 0.16|  1|FALSE | 0.16|BiocGenerics |\n|    39|    1|    1|unique.default      |     0| 0.16|  1|TRUE  | 0.16|base         |\n\n\n:::\n:::\n\n\n\n\n## Profiling -- `profr` package cted.\n\nWe can also plot the results using -- `proftools` package-\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(proftools)\nprofile_df2 <- readProfileData(\"profiler_test2.out\")\nplotProfileCallGraph(profile_df2, style = google.style, score = \"total\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/show_profr_result_plot-1.png){fig-align='center' width=384}\n:::\n\n```{.r .cell-code}\nunlink(\"profiler_test2.out\")\n```\n:::\n\n\n\n\n## Profiling with `profvis`\n\nYet another nice way to profile your code is by using Hadley Wickham's `profvis` package:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(profvis)\nprofvis({fun_fill_loop2(1e4, 'runif')\n  fun_fill_vec2(1e4, 'runif')\n})\n```\n:::\n\n\n\n\n## Profiling with `profvis` cted.\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"profvis html-widget html-fill-item\" id=\"htmlwidget-5881af99b4c430ab9af3\" style=\"width:100%;height:600px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-5881af99b4c430ab9af3\">{\"x\":{\"message\":{\"prof\":{\"time\":[1,2,2,2,3,4,4],\"depth\":[1,3,2,1,1,2,1],\"label\":[\".main\",\"force\",\"eval\",\"fun_fill_loop2\",\".main\",\"runif\",\"fun_fill_loop2\"],\"filenum\":[null,null,null,null,null,null,null],\"linenum\":[null,null,null,null,null,null,null],\"memalloc\":[24.78703308105469,25.01316070556641,25.01316070556641,25.01316070556641,25.23468017578125,25.45235443115234,25.45235443115234],\"meminc\":[0,0.2261276245117188,0,0,0.2215194702148438,0.2176742553710938,0],\"filename\":[null,null,null,null,null,null,null]},\"interval\":10,\"files\":[],\"prof_output\":\"/tmp/RtmpGTGWFR/filed0a6bbd9985.prof\",\"highlight\":{\"output\":[\"^output\\\\$\"],\"gc\":[\"^<GC>$\"],\"stacktrace\":[\"^\\\\.\\\\.stacktraceo(n|ff)\\\\.\\\\.$\"]},\"split\":\"h\"}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n## Optimizing your code\n\n::: {.blockquote}\n\nWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be deluded into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified.\n\n-- Donald Knuth\n\n:::\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n![](assets/xkcd_automation.png){height=\"350px\"}  \n[source: https://xkcd.com/1319]{.smaller}\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](assets/xkcd_is_it_worth_the_time_2x.png){height=\"350px\"}  \n[source: https://xkcd.com/1205/]{.smaller}\n\n:::\n::::\n\n## Ways to optimize the code\n\n::: {.incremental}\n\n- write it in a more efficient way, e.g. use vectorization or `*apply` family instead of loops etc.,\n- allocating memory to avoid copy-on-modify,\n- use package `BLAS` for linear algebra,\n- use `bigmemory` package,\n- GPU computations,\n- multicore support, e.g. `multicore`, `snow`\n- use `futures`\n- use `data.table` or `tibble` instead of `data.frame`\n\n:::\n\n## Copy-on-modify\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pryr)\norder <- 1024\nmatrix_A <- matrix(rnorm(order^2), nrow = order)\nmatrix_B <- matrix_A\n```\n:::\n\n\n\n\n. . .\n\nCheck where the objects are in the memory:\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddress(matrix_A)\naddress(matrix_B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x7fb674c32010\"\n[1] \"0x7fb674c32010\"\n```\n\n\n:::\n:::\n\n\n\n\n. . .\n\nWhat happens if we modify a value in one of the matrices?\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_B[1,1] <- 1\naddress(matrix_A)\naddress(matrix_B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x7fb674c32010\"\n[1] \"0x559fa4ed2e40\"\n```\n\n\n:::\n:::\n\n\n\n\n## Avoid copying by allocating memory\n\nNo memory allocation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|5\"}\nf1 <- function(to = 3, silent=F) {\n  tmp <- c()\n  for (i in 1:to) {\n    a1 <- address(tmp)\n    tmp <- c(tmp, i)\n    a2 <- address(tmp)\n    if (!silent) { print(paste0(a1, \" --> \", a2)) } \n  }\n}\nf1()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x559f989ffa00 --> 0x559fa2724b58\"\n[1] \"0x559fa2724b58 --> 0x559fa27075d0\"\n[1] \"0x559fa27075d0 --> 0x559fa24099d8\"\n```\n\n\n:::\n:::\n\n\n\n\n## Avoid copying by allocating memory cted.\n\nWith memory allocation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2|5\"}\nf2 <- function(to = 3, silent = FALSE) {\n  tmp <- vector(length = to, mode='numeric')\n  for (i in 1:to) {\n    a1 <- address(tmp)\n    tmp[i] <- i\n    a2 <- address(tmp)\n    if(!silent) { print(paste0(a1, \" --> \", a2)) }\n  }\n}\nf2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"0x559fa591af28 --> 0x559fa591af28\"\n[1] \"0x559fa591af28 --> 0x559fa591af28\"\n[1] \"0x559fa591af28 --> 0x559fa591af28\"\n```\n\n\n:::\n:::\n\n\n\n\n## Allocating memory -- benchmark.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nbenchmrk <- microbenchmark(f1(to = 1e3, silent = T), \n                           f2(to = 1e3, silent = T), \n                           times = 100L)\nggplot2::autoplot(benchmrk)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-9-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n\n## GPU\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA = matrix(rnorm(1000^2), nrow=1000) # stored: RAM, computed: CPU\nB = matrix(rnorm(1000^2), nrow=1000) \ngpuA = gpuMatrix(A, type = \"float\") # stored: RAM, computed: GPU\ngpuB = gpuMatrix(B, type = \"float\")\nvclA = vclMatrix(A, type = \"float\") # stored: GPU, computed: GPU\nvclB = vclMatrix(B, type = \"float\")\nbch <- microbenchmark(\n  cpu_ram = A %*% B,\n  gpu_ram = gpuA %*% gpuB,\n  gpu_vcl = vclA %*% vclB, \n  times = 10L) \n```\n:::\n\n\n\n\n[More on [Charles Determan's Blog](https://www.r-bloggers.com/r-gpu-programming-for-all-with-gpur/).]{.smaller}\n\n## GPU cted.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot2::autoplot(bch)\n```\n:::\n\n\n\n\n![](assets/gpu.png)\n\n## Parallelization using package `parallel`\n\nEasiest to parallelize is `lapply`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- lapply(1:2, function(x) { c(x, x^2, x^3) })\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 1 1\n\n[[2]]\n[1] 2 4 8\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(parallel)\nnum_cores <- detectCores() - 1\ncl <- makeCluster(num_cores) # Init cluster\nparLapply(cl, 1:2, function(x) { c(x, x^2, x^3)} )\nstopCluster(cl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 1 1\n\n[[2]]\n[1] 2 4 8\n```\n\n\n:::\n:::\n\n\n\n\n## {background-image=\"/assets/images/cover.webp\"}\n\n::: {.v-center .center}\n::: {}\n\n[Thank you!]{.largest}\n\n[Questions?]{.larger}\n\n[{{< meta current_year >}} ‚Ä¢ [SciLifeLab](https://www.scilifelab.se/) ‚Ä¢ [NBIS](https://nbis.se/) ‚Ä¢ [RaukR](https://nbisweden.github.io/raukr-2025)]{.smaller}\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/htmltools-fill-0.5.8.1/fill.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"../../site_libs/jquery-3.7.1/jquery.min.js\"></script>\n<script src=\"../../site_libs/d3-3.5.6/d3.min.js\"></script>\n<link href=\"../../site_libs/profvis-0.3.6.9000/profvis.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/profvis-0.3.6.9000/profvis.js\"></script>\n<script src=\"../../site_libs/profvis-0.3.6.9000/scroll.js\"></script>\n<link href=\"../../site_libs/highlight-11.10.0/textmate.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/highlight-11.10.0/highlight.min.js\"></script>\n<script src=\"../../site_libs/profvis-binding-0.4.0/profvis.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}