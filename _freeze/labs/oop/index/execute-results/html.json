{
  "hash": "72818aa7a03c35076998b6067e1fe9c1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Object-Oriented Programming in R\"\nauthor: \"Marcin Kierczak\"\ndescription: \"Class systems in the R language.\"\nimage: \"assets/featured.webp\"\nformat: html\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-note}\nDuring this lab, we will go through the most important features of 3 out of the 4 existing OOP systems in R:\n\n- S3,\n- S4,\n- R6.\n\nWhile S3 and S4 are base-R OOP systems, R6 is provided by the `R6` package. Both S3 and S4 follow the *functional OOP style* while `R6` is more similar to OOP models known from Java or C++. We will not cover the Reference Classes (a.k.a. RC) which is yet another base-R OOP model. Why? Well, it is really tricky to use and its documentation is not always complete...\n:::\n\n## S3 Classes\n\n- What is the class of the object returned by the `lm()` function?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nobj <- lm(speed ~ dist, data = cars)\nclass(obj)\n```\n:::\n\n\n\n\n- What basic data type is it build upon?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntypeof(obj)\n```\n:::\n\n\n\n\n- What attributes does the object of the `lm` class have?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nattributes(obj)\n```\n:::\n\n\n\n\n- What is the structure of the `lm` object?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(obj)\n```\n:::\n\n\n\n\n- Does the `lm` class implement own `str()`?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(obj)\n# compare to:\nstr(unclass(obj))\n\n# Answer: no\n```\n:::\n\n\n\n\n- What is the class of a `tibble`? You have to load the `tidyverse` package and use on of the built-in datasets, e.g. `mtcars` as argument to `as_tibble()` to check the class.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrequire(tidyverse)\nobj <- as_tibble(mtcars)\nclass(obj)\n```\n:::\n\n\n\n\n- What is the underlying data type?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ntypeof(obj)\n```\n:::\n\n\n\n\n- Is the `str()` function used by tibbles the default `str()`?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nstr(obj)\nstr(unclass(obj))\n# Answer: no\n```\n:::\n\n\n\n\n- Implement your own class `meta_frame` that is a `data.frame` with additional attributes:\n  - Character attribute `descr` (a description),\n  - `creation` attribute which will hold the creation date.\n\nCheck that it works, i.e. that it has the expected attributes and that it is a separate class.\n\n- How do you access the `description` field?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmeta_frame <- function(df, descr, creation) {\n  structure(\n    list(\n      df = df,\n      descr = descr,\n      creation = creation\n    ),\n    class = \"meta_frame\"\n  )\n}\nobj <- meta_frame(mtcars, \"The mtcars dataset\", \"10-06-2018\")\nstr(obj)\nobj$descr\n```\n:::\n\n\n\n\n- Design implementation of your own S3 class `protein` that stores the following information (you will implement the class in the next point, now just think and draw on paper if you wish):\n  - Protein sequence,\n  - Protein length,\n  - Post-translational modification (PTM) site coords,\n  - PTM type that can be either of: \"phosphorylation\", or \"methylation\".\n    \n- Implement the `protein` class from the previous point using the *constructor, validator and helper* design pattern. Try to reduce the number of input arguments to: +     + a sequence and \n  - A list of PTMs.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Constructor\nnew_protein <- function(sequence, length, ptm_site, ptm_type) {\n  stopifnot(is.character(sequence))\n  stopifnot(is.integer(length))\n  stopifnot(is.numeric(ptm_site))\n  stopifnot(is.character(ptm_type))\n  structure(\n    sequence,\n    length = length,\n    ptm_site = ptm_site,\n    ptm_type = ptm_type,\n    class = \"protein\"\n  )\n}\n\n# Helper\nprotein <- function(sequence, ptm) {\n  sequence <- sequence\n  len <- nchar(sequence)\n  ptm_site <- ptm[[1]]\n  ptm_type <- ptm[[2]]\n  validate_protein(new_protein(sequence, len, ptm_site, ptm_type))\n}\n\n# Validator\nvalidate_protein <- function(x) {\n  sequence <- x[1]\n  len <- attr(x, \"length\")\n  ptm_site <- attr(x, \"ptm_site\")\n  ptm_type <- attr(x, \"ptm_type\")\n  if (is.na(sequence)) {\n    stop(\"Sequence is missing!\", call. = FALSE)\n  }\n  if (length(ptm_site) != length(ptm_type)) {\n    stop(\"PTM type and site differ in length!\", call. = FALSE)\n  }\n  if ((sum(!ptm_type %in% c(\"phosphorylation\", \"methylation\"))) > 0) {\n    stop(\"Invalid PTM types detected!\", call. = FALSE)\n  }\n  return(x)\n}\n```\n:::\n\n\n\n\n- What would you improve in our implementation of `protein`. Is it really user friendly?\n- Write a generic `print` for the `protein` class. It should print e.g.:\n\n```         \n[1] \"============== Protein ==============\"\n[1] \"Sequence:ARNDKLLQWYTTARD\"\n[1] \"Length: 15 aa.\"\n[1] \"============== PTM section ==============\"\n[1] \"Site: 3\" \"Site: 5\"\n[1] \"Type: phosphorylation\" \"Type: methylation\"  \n```\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nprint.protein <- function(x) {\n  sequence <- unclass(x)\n  len <- attr(x, \"length\")\n  ptm_site <- attr(x, \"ptm_site\")\n  ptm_type <- attr(x, \"ptm_type\")\n  print(\"============== Protein ==============\")\n  print(paste0(\"Sequence:\", sequence))\n  print(paste0(\"Length: \", len, \" aa.\"))\n  print(\"============== PTM section ==============\")\n  print(paste0(\"Site: \", ptm_site))\n  print(paste0(\"Type: \", ptm_type))\n}\n```\n:::\n\n\n\n\n- Test that the `protein` class works as it should and that generic `print` works as well.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_prot <- protein(\n  \"ARNDKLLQWYTTARD\",\n  list(\n    site = c(3, 5),\n    type = c(\"phosphorylation\", \"methylation\")\n  )\n)\nclass(my_prot)\ntypeof(my_prot)\nprint(my_prot)\n```\n:::\n\n\n\n\n## S4 Classes\n\n- Re-write the `protein` class in S4 (with validation!).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Generator\n.protein <- setClass(\"protein\",\n  slots = c(\n    sequence = \"character\",\n    length = \"numeric\",\n    ptm_site = \"numeric\",\n    ptm_type = \"character\"\n  )\n)\n\n# Constructor\nprotein <- function(sequence, ptm) {\n  sequence <- sequence\n  len <- nchar(sequence)\n  ptm_site <- ptm[[1]]\n  ptm_type <- ptm[[2]]\n  if (is.na(sequence)) {\n    stop(\"Sequence is missing!\", call. = FALSE)\n  }\n  if (length(ptm_site) != length(ptm_type)) {\n    stop(\"PTM type and site differ in length!\", call. = FALSE)\n  }\n  if ((sum(!ptm_type %in% c(\"phosphorylation\", \"methylation\"))) > 0) {\n    stop(\"Invalid PTM types detected!\", call. = FALSE)\n  }\n  pt <- .protein(\n    sequence = sequence,\n    length = len,\n    ptm_site = ptm_site,\n    ptm_type = ptm_type\n  )\n  return(pt)\n}\n```\n:::\n\n\n\n\n- Create an S4 object of the `protein` class and check whether it works.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_prot <- protein(\n  \"ARNDKLLQWYTTARD\",\n  list(\n    site = c(3, 5),\n    type = c(\"phosphorylation\", \"methylation\")\n  )\n)\nclass(my_prot)\ntypeof(my_prot)\nstr(my_prot)\n```\n:::\n\n\n\n\n- Implement the generic `print` using S4 and check that it works.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsetMethod(\n  \"print\", \"protein\",\n  function(x) {\n    sequence <- x@sequence\n    len <- x@length\n    ptm_site <- x@ptm_site\n    ptm_type <- x@ptm_type\n    print(\"============== Protein ==============\")\n    print(paste0(\"Sequence:\", sequence))\n    print(paste0(\"Length: \", len, \" aa.\"))\n    print(\"============== PTM section ==============\")\n    print(paste0(\"Site: \", ptm_site))\n    print(paste0(\"Type: \", ptm_type))\n  }\n)\n\nprint(my_prot)\n```\n:::\n\n\n\n\n- Implement a new S4 class `ext_protein` that extends `protein` with 3 slots: \n  - Feature type,\n  - Feature position, and\n  - Feature value.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n.ext_protein <- setClass(\"ext_protein\",\n  contains = c(\"protein\"),\n  slots = c(\n    prot = \"protein\",\n    feature_type = \"character\",\n    feature_position = \"numeric\",\n    feature_value = \"character\"\n  )\n)\nmy_ext_prot <- .ext_protein(\n  prot = my_prot,\n  feature_type = \"modification\",\n  feature_position = 11,\n  feature_value = \"absent\"\n)\nclass(my_ext_prot)\ntypeof(my_ext_prot)\nstr(my_ext_prot)\n```\n:::\n\n\n\n\n## R6 Classes\n\n- Install and load the `R6` package,\n- Implement the `protein` class using R6 model and check that it works as expected:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nrequire(R6)\nprotein <- R6Class(\n  classname = \"protein\",\n  public = list(\n    seq = NA,\n    length = NULL,\n    ptm_site = NA,\n    ptm_type = NA,\n    initialize = function(seq = NA, ptm = NA) {\n      self$seq <- seq\n      self$length <- nchar(self$seq)\n      self$ptm_site <- ptm[[1]]\n      self$ptm_type <- ptm[[2]]\n      # Check types\n      stopifnot(is.character(seq))\n\n      # Validate\n      if (is.na(self$seq)) {\n        stop(\"Sequence is missing!\", call. = FALSE)\n      }\n      if (length(self$ptm_site) != length(self$ptm_type)) {\n        stop(\"PTM type and site differ in length!\", call. = FALSE)\n      }\n      if ((sum(!self$ptm_type %in% c(\"phosphorylation\", \"methylation\"))) > 0) {\n        stop(\"Invalid PTM types detected!\", call. = FALSE)\n      }\n    }\n  )\n)\n\nmy_new_prot <- protein$new(\n  seq = \"ARNDKLLQWYTTARD\", ptm =\n    list(\n      site = c(3, 5),\n      type = c(\"phosphorylation\", \"methylation\")\n    )\n)\nstr(my_new_prot)\n```\n:::\n\n\n\n\n**Congratulations! You are familiar with S3, S4 and R6 object models by now!**\n\n## Session\n\n<details>\n  <summary>Click here</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.3 (2025-02-28)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 24.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Etc/UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] bsplus_0.1.5    R6_2.6.1        lubridate_1.9.4 forcats_1.0.0  \n [5] stringr_1.5.1   dplyr_1.1.4     purrr_1.0.4     readr_2.1.5    \n [9] tidyr_1.3.1     tibble_3.2.1    ggplot2_3.5.2   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.6      jsonlite_2.0.0    compiler_4.4.3    tidyselect_1.2.1 \n [5] scales_1.3.0      yaml_2.3.10       fastmap_1.2.0     generics_0.1.3   \n [9] knitr_1.50        htmlwidgets_1.6.4 munsell_0.5.1     pillar_1.10.2    \n[13] tzdb_0.5.0        rlang_1.1.6       stringi_1.8.7     xfun_0.52        \n[17] timechange_0.3.0  cli_3.6.5         withr_3.0.2       magrittr_2.0.3   \n[21] digest_0.6.37     grid_4.4.3        hms_1.1.3         lifecycle_1.0.4  \n[25] vctrs_0.6.5       evaluate_1.0.3    glue_1.8.0        codetools_0.2-20 \n[29] colorspace_2.1-1  rmarkdown_2.29    tools_4.4.3       pkgconfig_2.0.3  \n[33] htmltools_0.5.8.1\n```\n\n\n:::\n:::\n\n\n\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}