{
  "hash": "e7337412314904540eada37c6e329225",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Vectorization\"\nsubtitle: \"RaukR 2023 â€¢ Advanced R for Bioinformatics\"\nauthor: \"Marcin Kierczak\"\ndescription: \"Speed up R code using vectorized functions.\"\nimage: \"assets/featured.webp\"\nformat: html\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-note}\nIn programming languages loop structures, either with or without conditions, are used to repeat commands over multiple entities. For and while loops as well as if-else statements are also often used in R, but perhaps not as often as in many other programming languages. The reason for this is that in R, there is an alternative called *vectorization* which usually is more efficient.\n:::\n\nVectorization implies that we can multiply all values in a vector in R by two by calling:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec.a <- c(1, 2, 3, 4)\nvec.a * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8\n```\n\n\n:::\n:::\n\n\n\n\nIn many other and languages as well as in R, you can also create this with a loop instead\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vec.a) {\n  vec.a[i] <- vec.a[i] * 2\n}\n\nvec.a\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 4 6 8\n```\n\n\n:::\n:::\n\n\n\n\nAs you saw in the lecture, this is far less efficient and not by any means easier to type and we hence tend to avoid loops when possible.\n\n## Task 1: A large matrix\n\n### Looping over a matrix\n\n- Create a 100000 by 10 matrix with the numbers 1:1000000\n- Write a `for`-loop that calculates the sum for each row of the matrix. \n- Verify that your row counts are consistent with what you obtain with the `apply()` function \n- Verify that your row counts are consistent with what you obtain with the `apply()` function `rowSums()` function\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nX <- matrix(1:1000000, nrow = 100000, ncol = 10)\nfor.sum <- vector()\n# Note that this loop is much faster if you outside the loop create an empty vector of the right size.\n# rwmeans <- vector('integer', 100000)\nfor (i in 1:nrow(X)) {\n  for.sum[i] <- sum(X[i, ])\n}\nhead(for.sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4500010 4500020 4500030 4500040 4500050 4500060\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\napp.sum <- apply(X, MARGIN = 1, sum)\nhead(app.sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4500010 4500020 4500030 4500040 4500050 4500060\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nrowSums.sum <- rowSums(X)\nhead(rowSums.sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4500010 4500020 4500030 4500040 4500050 4500060\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nidentical(for.sum, app.sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nidentical(for.sum, rowSums.sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nidentical(for.sum, as.integer(rowSums.sum))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n## Task 2: Fibonacci sequence\n\nDuring the lecture an approach to calculate factorials was implemented using recursion (function calling itself). Here we should use recursion to generate a sequence of Fibonacci numbers. A Fibonacci number is part of a series of number with the following properties:\n\n- the first two numbers in the Fibonacci sequence are either 1 and 1, or 0 and 1 (depending on the chosen starting point) \n- each subsequent number is the sum of the previous two. Hence:\n\n`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`\n\nor\n\n`1, 1, 2, 3, 5, 8, 13, 21, ...`\n\n### N-th Fibonacci number\n\nWrite a function that generates Fibonacci number using a recursive approach.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nfib_rec <- function(n) {\n  if (n == 0 || n == 1) {\n    return(n)\n  } else {\n    return(fib_rec(n - 1) + fib_rec(n - 2))\n  }\n}\n```\n:::\n\n\n\n\n### Generate Fibonacci sequence\n\nGenerate Fibonacci numbers from 0 to 10 using `*apply*` approach.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsapply(0:10, FUN = fib_rec)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  1  1  2  3  5  8 13 21 34 55\n```\n\n\n:::\n:::\n\n\n\n\n### Vectorized Fibonacci generator\n\nVectorize your Fibonacci number generating function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nvec_fib_rec <- Vectorize(fib_rec)\nvec_fib_rec(0:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  0  1  1  2  3  5  8 13 21 34 55\n```\n\n\n:::\n:::\n\n\n\n\n## Session\n\n<details>\n  <summary>Click here</summary>\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.3 (2025-02-28)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 24.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 \nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: Etc/UTC\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.4.3    fastmap_1.2.0     cli_3.6.5        \n [5] tools_4.4.3       htmltools_0.5.8.1 yaml_2.3.10       rmarkdown_2.29   \n [9] knitr_1.50        jsonlite_2.0.0    xfun_0.52         digest_0.6.37    \n[13] rlang_1.1.6       evaluate_1.0.3   \n```\n\n\n:::\n:::\n\n\n\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}